<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta charset="UTF-8">
  <title>Blockly and Babylon.js Integration</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/10.4.3/blockly.min.js"
    integrity="sha512-P0rA8GfrpGsMhoMxllI8i1+Gz69FG7+Dg+OFAskQPqBdxpL9UCO7TMGCdNKYI+b3oSFxEYFrW+ydHYegar9m8Q=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    body {
      display: flex;
      height: 100vh;
      margin: 0;
    }

    #blocklyDiv {
      height: 100%;
      width: 50%;
    }

    #rightArea {
      width: 50%;
      height: 100%;
    }

    #renderCanvas {
      width: 100%;
      height: 90%;
    }

    .blocklySvg text {
      font-family: 'Asap', sans-serif !important;
    }
  </style>
</head>

<body>
  <div id="blocklyDiv"></div>

  <div id="rightArea">
    <div id="menu">
      <button onclick="executeCode()">‚ñ∂Ô∏è Run</button>
      <button id="toggleDebug">ü™≤Debug</button>

      <button><input type="file" id="fileInput" style="display: none;" /><label for="fileInput"
          class="btn">üìÇOpen</label></button>
      <input type="text" id="projectName" placeholder="Enter project name here">
      <button onclick="exportCode()">üíæSave</button>
      <button id="fullscreenToggle">üñºÔ∏èFullscreen</button>
    </div>
    <canvas id="renderCanvas"></canvas>
  </div>

  <script>

    // Flock - Creative coding in 3D
    // Dr Tracy Gardner - https://github.com/tracygardner
    // Flip Computing Limited - flipcomputing.com

    const categoryColours = {
      "Scene": 160
    };

    const workspace = Blockly.inject('blocklyDiv', {
      theme: Blockly.Themes.Modern,
      renderer: 'zelos',
      zoom: {
        controls: true,  // Enables zoom controls (+, -, and home buttons)
        wheel: true,     // Enables zooming in/out using the mouse wheel
        startScale: 0.8, // Initial scale
        maxScale: 3,     // Max scale
        minScale: 0.3,   // Min scale
        scaleSpeed: 1.2  // How fast it zooms
      },
      toolbox: `
                <xml id="toolbox" style="display: none">
          <category name="Flock üêëüêëüêë"></category>
					<category name="Scene" colour="${categoryColours["Scene"]}">		
          <block type="create_scene"></block>
          <block type="set_sky_color"></block>
					<block type="create_ground"></block>
          <block type="create_box">
            <field name="COLOR">#9932CC</field> <!-- Default color -->
            <value name="WIDTH"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
            <value name="HEIGHT"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
            <value name="DEPTH"><shadow type="math_number"><field name="NUM">1</field></shadow></value>
            <value name="X"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
            <value name="Y"><shadow type="math_number"><field name="NUM">0.5</field></shadow></value>
            <value name="Z"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
          </block>
          <block type="create_sphere">
            <field name="COLOR">#9932CC</field> <!-- Default color -->
            <value name="DIAMETER_X">
              <shadow type="math_number">
                <field name="NUM">1</field>
              </shadow>
            </value>
            <value name="DIAMETER_Y">
              <shadow type="math_number">
                <field name="NUM">1</field>
              </shadow>
            </value>
            <value name="DIAMETER_Z">
              <shadow type="math_number">
                <field name="NUM">1</field>
              </shadow>
            </value>
            <value name="X">
              <shadow type="math_number">
                <field name="NUM">0</field>
              </shadow>
            </value>
            <value name="Y">
              <shadow type="math_number">
                <field name="NUM">0.5</field>
              </shadow>
            </value>
            <value name="Z">
              <shadow type="math_number">
                <field name="NUM">0</field>
              </shadow>
            </value>
          </block>
</category>
</xml>
            `
    });

    console.log("Welcome to Flock üêëüêëüêë");

    workspace.addChangeListener(function (event) {
      if (event.type === Blockly.Events.FINISHED_LOADING) {
        initializeVariableIndexes();
      }
    });

    Blockly.Blocks['create_scene'] = {
      init: function () {
        this.jsonInit({
          "type": "create_scene",
          "message0": "create_scene",
          "nextStatement": null,
          "colour": categoryColours["Scene"],
          "tooltip": "Creates a scene and runs the attached blocks.",
          "style": {
            "hat": "cap"
          }
        });
      }
    };


    Blockly.Blocks['create_ground'] = {
      init: function () {
        this.jsonInit({
          "type": "create_ground",
          "message0": "add ground with color %1",
          "args0": [
            {
              "type": "field_colour",
              "name": "COLOR",
              "colour": "#71BC78"
            }
          ],
          "previousStatement": null,
          "nextStatement": null,
          "colour": categoryColours["Scene"],
          "tooltip": "Adds a ground plane with collisions enabled to the scene, with specified color.",
          "helpUrl": ""
        });
      }
    };

    Blockly.Blocks['set_sky_color'] = {
      init: function () {
        this.jsonInit({
          "type": "set_sky_color",
          "message0": "set sky color %1",
          "args0": [
            {
              "type": "field_colour",
              "name": "COLOR",
              "colour": "#6495ED" // Default sky color
            }
          ],
          "previousStatement": null,
          "nextStatement": null,
          "colour": categoryColours["Scene"],
          "tooltip": "Sets the sky color of the scene.",
          "helpUrl": ""
        });
      }
    };

    Blockly.Blocks['create_box'] = {
      init: function () {
        let nextVariableName = "box" + nextVariableIndexes['box'];
        this.jsonInit({
          "type": "create_box",
          "message0": "create box as %1 %2 width %3 height %4 depth %5 x %6 y %7 z %8",
          "args0": [
            {
              "type": "field_variable",
              "name": "ID_VAR",
              "variable": nextVariableName
            },
            {
              "type": "field_colour",
              "name": "COLOR",
              "colour": "#9932CC"
            },
            {
              "type": "input_value",
              "name": "WIDTH",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "HEIGHT",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "DEPTH",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "X",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "Y",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "Z",
              "check": "Number"
            }
          ],
          "previousStatement": null,
          "nextStatement": null,
          "inputsInline": true,
          "colour": categoryColours["Scene"],
          "tooltip": "Creates a colored box with specified dimensions and position.",
          "helpUrl": ""
        });

        this.setOnChange(function (changeEvent) {
          if (!this.isInFlyout && changeEvent.type === Blockly.Events.BLOCK_CREATE && changeEvent.ids.includes(this.id)) {

            var variable = this.workspace.getVariable(nextVariableName);
            if (!variable) {
              variable = this.workspace.createVariable(nextVariableName, null);
              this.getField('ID_VAR').setValue(variable.getId());
            }

            nextVariableIndexes['box'] += 1;
          }

        });
      }
    };

    Blockly.Blocks['create_sphere'] = {
      init: function () {
        let nextVariableName = "sphere" + nextVariableIndexes['sphere'];
        this.jsonInit({
          "type": "create_sphere",
          "message0": "create sphere as %1 %2 diameter x %3 diameter y %4 diameter z %5 x %6 y %7 z %8",
          "args0": [
            {
              "type": "field_variable",
              "name": "ID_VAR",
              "variable": nextVariableName
            },
            {
              "type": "field_colour",
              "name": "COLOR",
              "colour": "#9932CC"
            },
            {
              "type": "input_value",
              "name": "DIAMETER_X",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "DIAMETER_Y",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "DIAMETER_Z",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "X",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "Y",
              "check": "Number"
            },
            {
              "type": "input_value",
              "name": "Z",
              "check": "Number"
            }
          ],
          "previousStatement": null,
          "nextStatement": null,
          "inputsInline": true,
          "colour": categoryColours["Scene"],
          "tooltip": "Creates a colored sphere with specified dimensions and position.",
          "helpUrl": ""
        });

        this.setOnChange(function (changeEvent) {
          if (!this.isInFlyout && changeEvent.type === Blockly.Events.BLOCK_CREATE && changeEvent.ids.includes(this.id)) {
            var variable = this.workspace.getVariable(nextVariableName);
            if (!variable) {
              variable = this.workspace.createVariable(nextVariableName, null);
              this.getField('ID_VAR').setValue(variable.getId());
            }

            nextVariableIndexes['sphere'] += 1;
          }
        });
      }
    };


    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    Blockly.JavaScript.forBlock['create_scene'] = function (block) {
      return code = `
        if (scene) scene.dispose();
        scene = createScene();
      `;
    };

    Blockly.JavaScript.forBlock['create_ground'] = function (block) {
      const color = block.getFieldValue('COLOR');

      return `
      (function() {
        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 100, height: 100, subdivisions: 2}, scene);
        const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);
        ground.receiveShadows = true;
        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.diffuseColor = new BABYLON.Color3.FromHexString("${color}");
        ground.material = groundMaterial;
      })();
      `;

    };

    Blockly.JavaScript.forBlock['set_sky_color'] = function (block) {
      const color = block.getFieldValue('COLOR');
      return `scene.clearColor = new BABYLON.Color3.FromHexString("${color}");\n`;
    };

    Blockly.JavaScript.forBlock['create_box'] = function (block) {
      const color = block.getFieldValue('COLOR');
      const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const depth = Blockly.JavaScript.valueToCode(block, 'DEPTH', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const posX = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      const posY = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      const posZ = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      let variable_name =
        Blockly.JavaScript.nameDB_.getName(block.getFieldValue('ID_VAR'), Blockly.Names.NameType.VARIABLE);

      const boxId = `box_${generateUUID()}`;
      meshMap[boxId] = block;

      return `(function() {
        const newBox = BABYLON.MeshBuilder.CreateBox("${boxId}", {width: ${width}, height: ${height}, depth: ${depth}, scene});
        newBox.position = new BABYLON.Vector3(${posX}, ${posY}, ${posZ});

        const boxBody = new BABYLON.PhysicsBody(newBox, BABYLON.PhysicsMotionType.STATIC, false, scene);

        const boxShape = new BABYLON.PhysicsShapeBox(
          new BABYLON.Vector3(0, 0, 0),
          BABYLON.Quaternion.Identity(),
          new BABYLON.Vector3(${width}, ${height}, ${depth}),
          scene
        );
        
        boxBody.shape = boxShape;
        boxBody.setMassProperties({mass: 1, restitution: 0.5});
        boxBody.setAngularDamping(100);
        boxBody.setLinearDamping(10);
        newBox.physics = boxBody;

        const material = new BABYLON.StandardMaterial("boxMaterial", scene);
        material.diffuseColor = new BABYLON.Color3.FromHexString("${color}");
        newBox.material = material;
        ${variable_name} = "${boxId}";
        \n
      })();
      `;

    };

    Blockly.JavaScript.forBlock['create_sphere'] = function (block) {
      const color = block.getFieldValue('COLOR');
      const diameterX = Blockly.JavaScript.valueToCode(block, 'DIAMETER_X', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const diameterY = Blockly.JavaScript.valueToCode(block, 'DIAMETER_Y', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const diameterZ = Blockly.JavaScript.valueToCode(block, 'DIAMETER_Z', Blockly.JavaScript.ORDER_ATOMIC) || '1';
      const posX = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      const posY = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0.5';
      const posZ = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      let variableName =
        Blockly.JavaScript.nameDB_.getName(block.getFieldValue('ID_VAR'), Blockly.Names.NameType.VARIABLE);

      const sphereId = `sphere_${generateUUID()}`;
      meshMap[sphereId] = block;

      return `(function() {
          const newSphere = BABYLON.MeshBuilder.CreateSphere("${sphereId}", {
            diameterX: ${diameterX},
            diameterY: ${diameterY},
            diameterZ: ${diameterZ},
            scene
          });
          newSphere.position = new BABYLON.Vector3(${posX}, ${posY}, ${posZ});

          const sphereBody = new BABYLON.PhysicsBody(newSphere, BABYLON.PhysicsMotionType.STATIC, false, scene);

          const sphereShape = new BABYLON.PhysicsShapeSphere(
            new BABYLON.Vector3(0, 0, 0),
            Math.max(${diameterX}, ${diameterY}, ${diameterZ}) / 2, // Approximation for irregular diameters
            scene
          );

          sphereBody.shape = sphereShape;
          sphereBody.setMassProperties({mass: 1, restitution: 0.5});
          sphereBody.setAngularDamping(100);
          sphereBody.setLinearDamping(10);
          newSphere.physics = sphereBody;

          const material = new BABYLON.StandardMaterial("sphereMaterial", scene);
          material.diffuseColor = new BABYLON.Color3.FromHexString("${color}");
          newSphere.material = material;
          ${variableName} = "${sphereId}";
          \n
        })();
        `;
    };



    const createScene = function () {
      const scene = new BABYLON.Scene(engine);
      hk = new BABYLON.HavokPlugin(true, havokInstance);
      scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);

      const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 4, -20), scene);
      camera.setTarget(BABYLON.Vector3.Zero());
      camera.attachControl(canvas, true);
      scene.createDefaultLight();
      scene.collisionsEnabled = true;
      return scene;
    };

    const canvas = document.getElementById("renderCanvas");

    const engine = new BABYLON.Engine(canvas, true, {stencil: true});
    let hk = null;
    let scene = null;
    let havokInstance = null;
    let engineReady = false;

    async function initialize() {
      BABYLON.Database.IDBStorageEnabled = true
      BABYLON.Engine.CollisionsEpsilon = 0.00005;
      havokInstance = await HavokPhysics();
      engineReady = true;

      scene = createScene();

      engine.runRenderLoop(function () {
        scene.render();
      });
    }

    initialize();
    const meshMap = {};


    let nextVariableIndexes = {
      mesh: 1,
      box: 1,
      sphere: 1,
      text: 1
    };

    function initializeVariableIndexes() {

      nextVariableIndexes = {
        mesh: 1,
        box: 1,
        sphere: 1,
        text: 1
      };

      const workspace = Blockly.getMainWorkspace(); // Get the current Blockly workspace
      const allVariables = workspace.getAllVariables(); // Retrieve all variables in the workspace

      // Process each type of variable
      Object.keys(nextVariableIndexes).forEach(function (type) {
        let maxIndex = 0; // To keep track of the highest index used so far
        // Regular expression to match variable names like 'type1', 'type2', etc.
        const varPattern = new RegExp(`^${type}(\\d+)$`);

        allVariables.forEach(function (variable) {
          const match = variable.name.match(varPattern);
          if (match) {
            const currentIndex = parseInt(match[1], 10);
            if (currentIndex > maxIndex) {
              maxIndex = currentIndex;
            }
          }
        });

        nextVariableIndexes[type] = maxIndex + 1;
      });

      // Optionally return the indexes if needed elsewhere
      return nextVariableIndexes;
    }

    window.addEventListener("resize", function () {
      engine.resize();
    });

    // Define your starter blocks XML string
    const initialBlocks =
      `<xml xmlns="http://www.w3.org/1999/xhtml">
            <block type="create_scene">
            <next>
            <block type="set_sky_color">
              <next>
    <block type="create_ground"></block>
              </next>
              </block>
              </next>
              </block>
            </xml>`;

    // Convert the XML string to a DOM element
    const xml = Blockly.utils.xml.textToDom(initialBlocks);

    // Load the XML into the workspace
    Blockly.Xml.domToWorkspace(xml, workspace);
    executeCode();

    function stripFilename(inputString) {

      const removeEnd = inputString.replace(/\(\d+\)/g, '');
      // Find the last occurrence of '/' or '\'
      let lastIndex = Math.max(removeEnd.lastIndexOf('/'), removeEnd.lastIndexOf('\\'));

      if (lastIndex === -1) {
        return removeEnd.trim();
      }

      return removeEnd.substring(lastIndex + 1).trim();
    }


    function exportCode() {

      const projectName = document.getElementById("projectName").value || "default_project";

      const json = Blockly.serialization.workspaces.save(workspace);
      const jsonString = JSON.stringify(json, null, 2); // Pretty-print the JSON

      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(jsonString));
      element.setAttribute('download', projectName + '.json');

      document.body.appendChild(element); // Required for Firefox
      element.click();
      document.body.removeChild(element);
    }


    window.onload = function () {
      document.getElementById('fileInput').addEventListener('change', function (event) {
        const reader = new FileReader();
        reader.onload = function () {
          const text = reader.result;
          const json = JSON.parse(text);

          // Set the project name as the value of the projectName input field
          document.getElementById('projectName').value = stripFilename(document.getElementById('fileInput').value.replace('.json', ''));

          Blockly.serialization.workspaces.load(json, workspace);
          executeCode();

        };
        reader.readAsText(event.target.files[0]);

      });
    }

    function executeCode() {
      if (engineReady) {
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        try {
          eval(code);
        } catch (error) {
          console.error("Error executing Blockly code:", error);
        }
      } else {
        // Check again in 100 milliseconds
        setTimeout(executeCode, 100);
      }
    }

    document.getElementById('fullscreenToggle').addEventListener('click', function () {
      if (!document.fullscreenElement) {
        // Go fullscreen
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
          document.documentElement.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
          document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
          document.documentElement.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) { /* Firefox */
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE/Edge */
          document.msExitFullscreen();
        }
      }
    });

    document.getElementById('toggleDebug').addEventListener('click', function () {
      if (scene.debugLayer.isVisible()) {
        document.getElementById('rightArea').style.width = '50%';
        document.getElementById('blocklyDiv').style.width = '50%';

        scene.debugLayer.hide();
      } else {
        document.getElementById('rightArea').style.width = '100%';
        document.getElementById('blocklyDiv').style.width = '0%';

        scene.debugLayer.show();

      }
    });

  </script>
</body>

</html>