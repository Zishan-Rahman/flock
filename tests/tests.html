<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flock Test Example</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
    </style>
    <style>
      /* CSS Variables for test filtering */

      #mocha-report[data-filter="failures"] .test.pass {
        display: none !important;
      }

      #mocha-report[data-filter="passes"] .test.fail {
        display: none !important;
      }

      #mocha-report[data-filter="all"] .test.fail, 
      #mocha-report[data-filter="all"] .test.pass {
        display: block !important;
      }

    </style>
  </head>
  <body>
    <h1>Flock Test Example</h1>
    <canvas
      id="renderCanvas"
      touch-action="none"
      style="width: 640px; height: 360px"
      tabindex="0"
    ></canvas>

    <script
      type="module"
      src="https://unpkg.com/mocha@10.2.0/mocha.js"
    ></script>
    <script type="module" src="https://unpkg.com/chai@4.3.7/chai.js"></script>

    <!-- Test selection interface -->
    <div style="margin: 20px 0;">
      <label for="testSelect" style="font-weight: bold; margin-right: 10px;">Select Test Suite:</label>
      <select id="testSelect" style="padding: 5px; margin-right: 10px;">
        <option value="">-- Choose a test suite --</option>
        <option value="babylon">Basic Babylon Tests</option>
        <option value="glide">Glide Animation Tests</option>
        <option value="ui">UI Text/Button Tests</option>
        <option value="stress">Stress Tests (Boxes)</option>
        <option value="objects">Object Creation Tests</option>
        <option value="sound">Sound Tests</option>
        <option value="translation">Translation/Movement Tests</option>
        <option value="rotation">Rotation Tests</option>
        <option value="scale">Scale Tests</option>
        <option value="materials">Materials Tests</option>
        <option value="physics">Physics Tests</option>
        <option value="effects">Effects Tests</option>
        <option value="animate">Animation API Tests</option>
        <option value="concurrency">Concurrency Tests</option>
        <option value="blocks">Block Tests</option>
        <option value="all">Run All Tests</option>
      </select>
      <button id="runTestBtn" style="padding: 5px 15px;">Run Tests</button>
      <button id="clearTestBtn" style="padding: 5px 15px; margin-left: 5px;">Clear Results</button>
    </div>

    <!-- Mocha test results will be displayed here -->
    <div id="mocha"></div>

    <!-- Import the test suite -->
    <script type="module">

      // Define test suites in an array
      // note: this array will change as test suites are refined
      // some test files (materials, physics, sound, 3xtransform) have several top-level describe blocks
      // the importFn is the function to call to register the tests with mocha - but if standardised the column could be removed
      // if the tests were standardised and imported with a glob, (most of) the array could be generated automatically, reducing maintenance
      // alternatively, the array can be customised to run tagged tests or subsets of tests
      const testSuiteDefinitions = [
        { id: "babylon", name: "Basic Babylon Tests", importPath: "./babylon.test.js", importFn: "runTests", pattern: "Flock API Tests" },
        { id: "glide", name: "Glide Animation Tests", importPath: "./glide.test.js", importFn: "runGlideToTests", pattern: "glideTo function tests" },
        { id: "ui", name: "UI Text/Button Tests", importPath: "./uitextbutton.test.js", importFn: "runUITests", pattern: "UIText, UIButton, UIInput, and UISlider function tests" },
        { id: "stress", name: "Stress Tests (Boxes)", importPath: "./boxes.test.js", importFn: "runStressTests", pattern: "Stress test for many boxes" },
        { id: "objects", name: "Object Creation Tests", importPath: "./objects.test.js", importFn: "runCreateObjectTests", pattern: "createObject tests" },
        { id: "sound", name: "Sound Tests", importPath: "./sound.test.js", importFn: "runSoundTests", pattern: "@sound" },
        { id: "translation", name: "Translation/Movement Tests", importPath: "./transform.translate.test.js", importFn: "runTranslationTests", pattern: "@translation" },
        { id: "rotation", name: "Rotation Tests", importPath: "./transform.rotate.test.js", importFn: "runRotationTests", pattern: "@rotation" },
        { id: "scale", name: "Scale Tests", importPath: "./transform.scale.test.js", importFn: "runScaleTests", pattern: "@scale" },
        { id: "materials", name: "Materials Tests", importPath: "./materials.test.js", importFn: "runMaterialsTests", pattern: "@materials" },
        { id: "physics", name: "Physics Tests", importPath: "./physics.test.js", importFn: "runPhysicsTests", pattern: "@physics" },
        { id: "effects", name: "Effects Tests", importPath: "./effects.test.js", importFn: "runEffectsTests", pattern: "Effects API" },
        { id: "animate", name: "Animation API Tests", importPath: "./animate.test.js", importFn: "runAnimateTests", pattern: "Animation API Tests" },
        { id: "concurrency", name: "Concurrency Tests", importPath: "./concurrency.test.js", importFn: "runConcurrencyTests", pattern: "Concurrency and Stress Tests" },
        { id: "blocks", name: "Block Tests", importPath: "./blocks.test.js", importFn: "runBlocksTests", pattern: "blocks.js tests" }
      ];

      import * as flockmodule from "../flock.js";
      import "@babylonjs/core/Debug/debugLayer";
      import "@babylonjs/inspector";

      const flock = flockmodule.flock;
      flock.modelPath = "../models/";

      await flock.initialize();

      mocha.setup({
        ui: "bdd",
        reporter: 'html',
        cleanReferencesAfterRun: false
      });

      try {
        let iframe = document.getElementById("flock-iframe");

        if (iframe) {
          await iframe.contentWindow?.flock?.disposeOldScene();
        } else {
          // Step 3: If the iframe does not exist, create a new one
          iframe = document.createElement("iframe");
          iframe.id = "flock-iframe";
          iframe.style.display = "none";
          document.body.appendChild(iframe);
        }

        await new Promise((resolve) => {
          iframe.onload = () => {
            resolve();
          };
          iframe.src = "about:blank";
        });

        const iframeWindow = iframe.contentWindow;
        iframeWindow.flock = flock;

        await iframeWindow.flock.initializeNewScene();
      } catch (e) {
        console.log(e);
      }

      // Test suite mapping
      // Import all test modules and run them to register tests
      async function loadAllTests() {
        // First, load all test modules
        for (const suite of testSuiteDefinitions) {
          try {
            const module = await import(suite.importPath);
            // Call the function to register tests with mocha, but don't run them yet
            if (suite.id === "babylon") {
              module[suite.importFn](flock, chai.expect);
            } else {
              module[suite.importFn](flock);  
            }
          } catch (error) {
            console.error(`Error loading test suite ${suite.id}:`, error);
          }
        }

        let returnableTestSuites = {
          babylon: () => runTests(flock, chai.expect),
          glide: () => runGlideToTests(flock),
          ui: () => runUITests(flock),
          stress: () => runStressTests(flock),
          objects: () => runCreateObjectTests(flock),
          sound: () => runSoundTests(flock),
          translation: () => runTranslationTests(flock),
          rotation: () => runRotationTests(flock),
          scale: () => runScaleTests(flock),
          materials: () => runMaterialsTests(flock),
          physics: () => runPhysicsTests(flock),
          effects: () => runEffectsTests(flock),
          animate: () => runAnimateTests(flock),
          concurrency: () => runConcurrencyTests(flock),
          blocks: () => runBlocksTests(),
          all: () => {
            runTests(flock, chai.expect);
            runGlideToTests(flock);
            runUITests(flock);
            runStressTests(flock);
            runCreateObjectTests(flock);
            runSoundTests(flock);
            runTranslationTests(flock);
            runRotationTests(flock);
            runScaleTests(flock);
            runMaterialsTests(flock);
            runPhysicsTests(flock);
            runEffectsTests(flock);
            runAnimateTests(flock);
            runConcurrencyTests(flock);
            runBlocksTests();
          }
        }
      return(returnableTestSuites);
      }

      // Load all tests immediately, and get test suite mapping
      const testSuites = await loadAllTests();

      // Setup test selection interface
      const testSelect = document.getElementById('testSelect');
      const runTestBtn = document.getElementById('runTestBtn');
      const clearTestBtn = document.getElementById('clearTestBtn');

      function setupFailuresLink() {
        const mochaReport = document.getElementById('mocha-report');
        const failuresLink = document.querySelector('#mocha-stats .failures a');
        const passesLink = document.querySelector('#mocha-stats .passes a');

        if (failuresLink) {
          failuresLink.onclick = function() {
            // Show only failures
            mochaReport.dataset.filter = 'failures';
            
            // Scroll to first failure
            const firstFailure = document.querySelector('#mocha-report .test.fail');
            if (firstFailure) {
              firstFailure.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // toggle back to all results on next click
            const oldText = failuresLink.innerHTML;
            failuresLink.innerHTML = "(toggle) "+oldText;
            failuresLink.onclick = function() { mochaReport.dataset.filter = 'all'; failuresLink.innerHTML = oldText ;return false; };

            return false;
          };
        }
        if (passesLink) {
          passesLink.onclick = function() {
            // Show only passes
            mochaReport.dataset.filter = 'passes';
            // toggle back to all results on next click
            const oldText = passesLink.innerHTML;
            passesLink.innerHTML = "(toggle) "+oldText;
            passesLink.onclick = function() { mochaReport.dataset.filter = 'all'; passesLink.innerHTML = oldText; return false; };
            return false;
          };
        }
      }

      runTestBtn.addEventListener('click', () => {
        const selectedTest = testSelect.value;
        //console.log("Selected test suite:", selectedTest);
        //console.log("Pattern being used:", testSuiteDefinitions.find(suite => suite.id === selectedTest)?.pattern);
        if (!selectedTest) {
          alert('Please select a test suite to run');
          return;
        }

        // Clear previous results
        document.getElementById('mocha').innerHTML = '';

        // Reset any previous grep pattern
        mocha.grep(null);
        
        // If a specific test suite is selected (not "all")
        if (selectedTest !== "all") {
          // Find the pattern for the selected test suite
          const testSuite = testSuiteDefinitions.find(suite => suite.id === selectedTest);
          if (testSuite && testSuite.pattern) {
            // Apply the grep pattern to filter tests
            mocha.grep(testSuite.pattern);
          }
        }
        
        // Run the filtered tests
        let runner = mocha.run();
        runner.on("end", setupFailuresLink);
      });

      clearTestBtn.addEventListener('click', () => {
        document.getElementById('mocha').innerHTML = '';
      });

      // Show debug layer
      try {
        await flock.scene.debugLayer.show({
          embedMode: true,
          enableClose: true,
          enablePopup: true,
        });
      } catch (error) {
        console.error("Error showing debug layer:", error);
      }

      // Don't run any tests by default - wait for user selection
    </script>
  </body>
</html>